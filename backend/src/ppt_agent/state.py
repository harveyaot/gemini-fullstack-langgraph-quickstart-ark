from __future__ import annotations

from typing import TypedDict, Optional, Dict, Any, List
from typing_extensions import Annotated
from pydantic import BaseModel

import operator


class ExecutionRecord(BaseModel):
    """Model for tool execution records"""

    tool_name: str
    status: str  # "succeeded" or "failed"
    result: Dict[str, Any]


class PPTOverallState(TypedDict):
    """Main state for PPT agent workflow - used for overall state management and all outputs"""

    messages: Annotated[
        List[Dict[str, Any]], operator.add
    ]  # Plain dict messages with custom reducer
    # Routing and coordination fields
    next_tool: Optional[str]
    tool_args: Optional[Dict[str, Any]]
    current_tool_call: Optional[Any]
    # Shared data across nodes
    ppt_outline: Optional[
        Dict[str, Any]
    ]  # Generated by outline node, used by HTML node
    sources_gathered: Annotated[
        List[Dict[str, Any]], operator.add
    ]  # Search results from web searches
    # Tool execution tracking
    tool_execution_history: Annotated[
        List[Dict[str, Any]], operator.add
    ]  # Track each node execution and results
    web_results_summary: Annotated[
        List[str], operator.add
    ]  # Summary of web search results
    total_pages: Optional[int]  # Total pages of the PPT
    scenario: Optional[str]  # Sentiment of the PPT

    # Research reflection fields (temporary, for routing decisions)
    reflection_should_continue: Optional[bool]
    reflection_suggested_queries: Optional[List[str]]
    reflection_rationale: Optional[str]


# Very Specific Input States - Each node gets exactly what it needs
class CoordinatorInputState(TypedDict):
    """Input state for coordinator node - analyzes full conversation"""

    messages: List[Dict[str, Any]]  # Plain dict messages


class WebSearchInputState(TypedDict):
    """Input state for web search node - only needs search queries"""

    queries: List[str]  # From PPTLLMTools.WebSearch.queries
    tool_call_id: Optional[str]  # Tool call ID for response
    tool_execution_history: Annotated[
        List[Dict[str, Any]], operator.add
    ]  # Tool execution history for consecutive check


class OutlineInputState(TypedDict):
    """Input state for outline generation node - needs user request, reference documents, and total pages"""

    user_request: str  # From PPTLLMTools.GenPptOutline.user_request
    ref_documents: str  # Extracted from conversation tool messages
    total_pages: int  # From PPTLLMTools.GenPptOutline.total_pages
    tool_call_id: Optional[str]  # Tool call ID for response


class HtmlInputState(TypedDict):
    """Input state for HTML generation node - needs outline, user request, and theme"""

    user_request: str  # From PPTLLMTools.GenPptHtml.user_request
    ppt_outline: Dict[str, Any]  # From previous outline generation
    theme: str  # From PPTLLMTools.GenPptHtml.theme
    tool_call_id: Optional[str]  # Tool call ID for response


class ModifyInputState(TypedDict):
    """Input state for HTML modification node - needs page and modifications"""

    page_number: int  # From PPTLLMTools.ModifyPptHtml.page_number
    modification_suggestions: (
        str  # From PPTLLMTools.ModifyPptHtml.modification_suggestions
    )
    tool_call_id: Optional[str]  # Tool call ID for response


class ThemeAndPagesAckInputState(TypedDict):
    """Input state for theme and pages acknowledgment node - coordinator passes suggested theme and pages"""

    theme: str  # Suggested theme from coordinator's tool args
    total_pages: int  # Suggested total pages from coordinator's tool args
    tool_call_id: Optional[str]  # Tool call ID for response


class FinalizeInputState(TypedDict):
    """Input state for finalize response node - needs full conversation"""

    messages: List[Dict[str, Any]]  # Plain dict messages
